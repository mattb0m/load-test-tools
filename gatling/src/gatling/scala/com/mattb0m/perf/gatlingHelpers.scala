package com.mattb0m.perf

import java.net.InetAddress
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.UUID
import scala.collection.mutable.Map
import scala.concurrent.duration._
import io.gatling.core.Predef._
import io.gatling.http.Predef._
import io.gatling.http.client.Request
import io.gatling.http.protocol.HttpProtocolBuilder
import io.gatling.core.pause.{Constant, Disabled}
import io.gatling.core.structure.ChainBuilder
import scala.util.control.Breaks._
import java.time.Instant

object UuidFeeder {
	val feed = Iterator.continually(scala.collection.immutable.Map("uuid" -> UUID.randomUUID().toString))
}

// Support dynamic HTTP header injection on all requests
trait InjectorCallback {
	def call(): String
}

class HttpHeaderInjector {
	val callbacks = Map[String, InjectorCallback]()
	
	// Add dynamic header generated by a callback function
	def addHeader(name:String, cb:InjectorCallback): Unit = {
		this.callbacks.addOne(name, cb)
	}
	
	def addDynatraceHeader(request:Request, session:Session): Unit = {
		val hostname = InetAddress.getLocalHost().getHostName()
		val TE = getClass.getSimpleName + "_" +LocalDateTime.now.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) /* Test run ID */
		val ID = UUID.randomUUID.toString /* Unique request ID */
		val VU = hostname + "_" + session.scenario + "_" + session.userId /* unique virtual user ID */
		val NA = request.getName /* timer/sampler/request name */
		val SI = "GATLING" /* source/testing tool */
		val AN = hostname /* agent name (source) */
		val SN = session.scenario /* scenario/thread group */
		request.getHeaders.set("x-dynaTrace", "ID="+ID+";VU="+VU+";NA="+NA+";SI="+SI+";AN="+AN+";SN="+SN+";TE="+TE)
	}
	
	/* add all headers to HTTP request signature */
	def injectHeaders(http:HttpProtocolBuilder, enableDynatrace:Boolean): HttpProtocolBuilder = {
		return http.sign((request, session) => {
			for ((name,cb) <- this.callbacks) request.getHeaders.set(name, cb.call())
			if(enableDynatrace) addDynatraceHeader(request, session)
		})
	}
}

// Load config values from System properties
object ConfigLoader {
	def load(name:String, default:String): String = {
		return System.getProperty(name, default)
	}
	
	def loadInt(name:String, default:Int): Int = {
		return System.getProperty(name, default.toString).toInt
	}
	
	def loadDouble(name:String, default:Double): Double = {
		return System.getProperty(name, default.toString).toDouble
	}
	
	def loadBool(name:String, default:Boolean): Boolean = {
		return System.getProperty(name, default.toString).toBoolean
	}
}

// Basic config for most load tests
class BasicTestConfig {
	// constants
	val PacingDefault = 0
	val PacingUndefined = -1
	val UsersDefault = 1
	val UsersUndefined = -1
	
	// Load profile (in seconds)
	val rampUp = ConfigLoader.loadInt("rampUp", 1).seconds
	val holdLoad = ConfigLoader.loadInt("holdLoad", 600).seconds
	val rampDown = ConfigLoader.loadInt("rampDown", 1).seconds
	val maxDuration = rampUp + holdLoad + rampDown
	
	// Respect think time or not
	val pauses = if(ConfigLoader.loadBool("pauses", true)) Constant else Disabled // Execute pauses ?
	
	// pacing, in seconds, matching pattern "users\d{2}", fall back to PacingDefault
	val pacingAll = ConfigLoader.loadInt("pacingAll", this.PacingDefault).seconds
	val pacingMap = Map[Int, FiniteDuration]()
	
	breakable {
	for(i <- 1 to 99) {
		val num = ConfigLoader.loadInt("pacing%02d".format(i), this.PacingUndefined)
		if(num == this.PacingUndefined || num < 0) {
			break()
		} else {
			this.pacingMap.addOne(i, num.seconds)
		}
	}}
	
	// User counts, matching pattern "users\d{2}", fall back to UsersDefault
	val usersAll = ConfigLoader.loadInt("usersAll", this.UsersDefault)
	val usersMap = Map[Int, Int]()
	
	breakable {
	for(i <- 1 to 99) {
		val num = ConfigLoader.loadInt("users%02d".format(i), this.UsersUndefined)
		if(num == this.UsersUndefined || num < 0) {
			break()
		} else {
			this.usersMap.addOne(i,num)
		}
	}}
	
	// Get user count by test case index, fall back to usersAll, which falls back to UsersDefault
	def users(index:Int): Int = {
		if(this.usersMap.contains(index)) {
			return this.usersMap(index)
		} else {
			return this.usersAll
		}
	}
	
	// Get pacing by test case index, fall back to pacingAll, which falls back to PacingDefault
	def pacing(index:Int): FiniteDuration = {
		if(this.pacingMap.contains(index)) {
			return this.pacingMap(index)
		} else {
			return this.pacingAll
		}
	}
}

// Single load test step
class TestStep (actions:ChainBuilder) {
	val name = this.getClass.getSimpleName.stripSuffix("$")
	val requests = group(name) {actions}
}

// A grouped load test case, calling individual Steps/Actions
class TestCase(init:ChainBuilder, pacing:FiniteDuration, actions:ChainBuilder*) {
	// Allow construction without the Init block
	def this(pacing:FiniteDuration, actions:ChainBuilder*) = this(exec(), pacing, actions:_*)
	
	// Test case structure
	val name = this.getClass.getSimpleName.stripSuffix("$")
	val scn = scenario(name).exec(group(s"_TC_${name}") {init.exitHereIfFailed}).forever {
		group(s"_TC_${name}") {
			exitBlockOnFail {
				pace(pacing)
				.exec(actions)
			}
		}
	}
}

// Time helpers
object TimeHelper {
	
	// Get seconds since EPOCH
	def now(): Long = {
		return Instant.now().getEpochSecond()
	}
}

// Auth token helpers
object TokenHelper {
	// Test token expiration, based on generation time and TTL (expressed in seconds)
	def isExpiredSec(session:Session, start:String, ttl:String): Boolean = {
		return (!session.contains(start)
			|| !session.contains(ttl)
			|| (session(start).as[Long] + session(ttl).as[Long] <= TimeHelper.now())
		);
	}
}

// VUser session management
object SessionHelper {
	// Flush all cookies and cache
	def flushAll():ChainBuilder = {
		return exec(flushCookieJar).exec(flushHttpCache)
	}
	
	def flushCookies():ChainBuilder = {
		return exec(flushCookieJar)
	}
	
	def flushCache():ChainBuilder = {
		return exec(flushHttpCache)
	}
}
